\section{Theorie-Praxis-Transfer}
Anwendung theoretischer Konzepte auf das Projektszenario
In diesem Abschnitt werden die theoretischen Grundlagen der Fehlerbehandlung und Datensicherheit auf die Konzeption der in Abschnitt 5 realisierten Benutzerverwaltung übertragen. Ziel ist es, eine stabile Struktur zu entwerfen, die sowohl Betriebssicherheit als auch Wartbarkeit bietet.

\subsection{Identifikation und Analyse relevanter Problemstellungen}
Die Entwicklung einer dateibasierten Benutzerverwaltung stellt in der Praxis bei der Umsetzung mehrere Herausforderungen dar, die in der theoretischen Betrachtung häufig vereinfacht dargestellt werden. Im Gegensatz zu datenbankgestützten Systemen, die Mechanismen zur Sicherstellung von Konsistenz und Integrität bereits bereitstellen, müssen diese Aspekte bei der direkten Arbeit mit Dateisystemen eigenständig umgesetzt werden. Die Stabilität und Zuverlässigkeit der Anwendung hängen daher maßgeblich von der korrekten Behandlung dieser Problemfelder ab.

Ein zentrales Risiko ist die Unsicherheit bei Dateiein- und -ausgabeoperationen. Zugriffe auf das Dateisystem können aus unterschiedlichen Gründen fehlschlagen, etwa aufgrund fehlender Dateien, unzureichender Zugriffsrechte oder externer Sperren durch andere Prozesse. Ohne geeignete Fehlerbehandlung können solche Situationen zu einem unkontrollierten Programmabbruch führen. Dies hätte nicht nur negative Auswirkungen auf die Benutzererfahrung, sondern könnte auch unvollständige oder beschädigte Daten hinterlassen.

Ein weiteres wesentliches Problemfeld ist die fachliche Konsistenz der gespeicherten Daten. Insbesondere bei Benutzerkonten muss sichergestellt werden, dass eindeutige Identifikatoren wie E-Mail-Adressen nicht mehrfach vergeben werden. Diese Prüfung muss vor dem Speichern der Daten erfolgen, da eine nachträgliche Korrektur in dateibasierten Systemen nur mit zusätzlichem Aufwand möglich ist.

Darüber hinaus spielt die Datensicherheit eine zentrale Rolle. Da die Benutzerverwaltung sensible Informationen wie Zugangsdaten verarbeitet, ist eine Speicherung im Klartext nicht akzeptabel. Bei dateibasierten Lösungen müssen geeignete Schutzmechanismen explizit implementiert werden, um im Falle unbefugten Datenzugriffs Missbrauch zu verhindern \footcite[Vgl.][]{OWASP_b}.
Diese identifizierten Problemstellungen bilden die Grundlage für den gezielten Transfer theoretischer Konzepte in die praktische Anwendungsarchitektur.

\subsection{Anwendung theoretischer Konzepte}
\subsubsection{Strategie der Fehlerbehandlung: Checked vs. Unchecked Exceptions}
Ein zentrales theoretisches Konzept in der Softwareentwicklung ist die Unterscheidung zwischen checked und unchecked Exceptions. Laut den Empfehlungen von Oracle sollten Checked Exceptions für erwartbare Fehlersituationen verwendet werden, aus denen sich das System kontrolliert erholen kann \footcite[Vgl.][]{Oracle_c}.

In diesem Projekt wurde dieses Prinzip auf jeden Fall bei der doppelten Benutzerregistrierung angewendet. Eine mehrfache Verwendung derselben E-Mail-Adresse stellt keinen technischen Fehler dar, sondern eine fachlich erwartbare Benutzereingabe. Aus diesem Grund wurde die DuplicateUserException als Checked Exception implementiert. Dadurch wird der aufrufende Code bereits zu Kompilierzeit dazu gezwungen, diesen Fall explizit zu behandeln. Das System bleibt stabil und der Benutzer erhält eine verständliche Rückmeldung mit der Möglichkeit, seine Eingabe zu korrigieren.

Im Gegensatz dazu werden technische Fehler wie etwa Parsing-Probleme beim Einlesen von CSV-Daten als Unchecked Exceptions behandelt. Diese deuten in der Regel auf fehlerhafte Daten oder Programmierfehler hin und lassen sich nicht sinnvoll durch Benutzereingaben beheben. Eine Weitergabe dieser Fehler während der Laufzeit ist daher angemessen und unterstützt die Fehlersuche während der Entwicklung \footcite[Vgl.][]{Oracle_c}.

\subsubsection{Ressourcenmanagement und Betriebssicherheit}

Ein häufiges Problem bei dateibasierten Anwendungen ist der sogenannte Resource-Leak. Werden Datei-Streams nicht korrekt geschlossen, können offene Ressourcen im Betriebssystem verbleiben, was langfristig zu Dateisperren und Systeminstabilitäten führt.

Zur Lösung dieses Problems wurde das theoretische Konzept des Try-with-Resources eingesetzt, das seit Java 7 verfügbar ist. Dieses Konstrukt stellt sicher, dass alle verwendeten Ressourcen automatisch geschlossen werden, unabhängig davon, ob während der Verarbeitung eine Exception auftritt \footcite[Vgl.][]{Oracle_c}. In der Persistenzschicht (UserStore) werden sowohl Lese- als auch Schreiboperationen konsequent innerhalb dieses Konstrukts ausgeführt. Dadurch wird gewährleistet, dass selbst bei schwerwiegenden Fehlern wie etwa einem vollen Datenträger keine offenen Dateihandles zurückbleiben.

\subsubsection{Architektonische Trennung (Separation of Concerns)}

Das Prinzip der Separation of Concerns fordert eine klare Trennung der Verantwortlichkeiten innerhalb einer Softwarearchitektur \footcite[Vgl.][]{Microsoft}. In der Umsetzung dieses Projekts wurde dieses Prinzip durch eine einfache Schichtenarchitektur vermittelt. Die Persistenzschicht ist ausschließlich für den Zugriff auf das Dateisystem zuständig und enthält keine Logik für die Benutzerinteraktion.

Fehler werden dort nicht direkt ausgegeben, sondern an die aufrufende Schicht weitergeleitet. Dadurch bleibt die Datenhaltung unabhängig von der konkreten Benutzeroberfläche. Diese Entkopplung verbessert sowohl die Wartbarkeit als auch die Wiederverwendbarkeit des Codes und ermöglicht, die Benutzeroberfläche bei Bedarf auszutauschen, ohne die Persistenzlogik anzupassen.

\subsection{Herausforderungen und Lösungsentscheidungen}
\subsubsection{Fehlertoleranz bei Datenkorruption}
CSV-basierte Dateiformate sind anfällig für manuelle Bearbeitungsfehler. Bereits eine fehlerhaft formatierte Zeile kann dazu führen, dass der gesamte Lesevorgang abbricht. Um dieses Risiko zu minimieren, wurde eine fehlertolerante Parsing-Strategie implementiert.
Jede Zeile der Benutzerdatei wird einzeln validiert. Tritt bei einer Zeile ein Fehler auf, wird die Exception lokal abgefangen, protokolliert und der Lesevorgang mit der nächsten Zeile fortgesetzt. Dieses Vorgehen folgt dem Prinzip der Graceful Degradation und stellt sicher, dass möglichst viele valide Datensätze geladen werden können, ohne die Anwendung zu blockieren.

\subsubsection{Sicherheit: Hashing von Passwörtern}
Für die Speicherung von Passwörtern wurde bewusst auf reversibel Verschlüsselungsverfahren verzichtet. Stattdessen werden Passwörter mittels des Hash-Algorithmus SHA-256 gespeichert. Da Hashfunktionen Einwegfunktionen sind, können die ursprünglichen Passwörter nicht wiederhergestellt werden, was im Falle eines Datenlecks einen erhöhten Schutz bietet \footcite[Vgl.][]{Oracle_c}.
Sicherheitsstandards wie die OWASP-Richtlinien empfehlen für produktive Anwendungen spezialisierte Hash-Algorithmen wie bcrypt oder Argon2, da diese durch einen konfigurierbaren Arbeitsfaktor Brute-Force-Angriffe erheblich erschweren \footcite[Vgl.][]{OWASP_a}. Im Rahmen dieser Projektarbeit wurde jedoch aus Gründen der Komplexität und unter Verwendung der Standard-Java-API SHA-256 als angemessener Kompromiss zwischen Sicherheit und Implementierungsaufwand gewählt.
