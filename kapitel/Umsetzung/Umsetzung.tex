\section{Umsetzung in Java}
\subsection{Zielsetzung und Architektur}
Ziel der praktischen Umsetzung war die Entwicklung einer Java-basierten Konsolenanwendung (CLI), die als Identity-Management-System dient. Die Kernanforderungen umfassen die Speicherung von Benutzerdaten ohne den Einsatz einer externen Datenbank, eine Registrierungslogik sowie eine sichere Authentifizierung. Besonderer Wert wurde hierbei auf die Stabilität der Anwendung gegenüber Fehlbedienungen, technischen Störungen und inkonsistenten Datenzuständen gelegt.
 
Die Architektur der Anwendung orientiert sich am Prinzip der Separation of Concerns, um Verantwortlichkeiten klar zu trennen \footcite[Vgl.][]{Microsoft}. Das System ist modular in folgende Komponenten gegliedert:

\begin{itemize}
    \item Main (Präsentationsschicht): Diese Klasse fungiert als zentraler Einstiegspunkt und als Controller. Sie übernimmt die Interaktion mit dem Benutzer über Scanner-Objekte, validiert Eingaben syntaktisch (z. B. die Prüfung auf das Vorhandensein eines „@“-Zeichens in E-Mail-Adressen) und steuert den gesamten Programmfluss. Sie ist die einzige Komponente, die Ausgaben in der Konsole (System.out) ausgeben darf.
    \item User (Model): repräsentiert die Fachlichkeit eines Benutzers. Die Klasse kapselt die Logik zur Serialisierung (Konvertierung in das CSV-Format) sowie sicherheitskritische Aspekte wie das Passwort-Hashing.
    \item UserStore (Persistenzschicht): Diese Klasse verwaltet den physischen Zugriff auf das Dateisystem (data/users.txt). Hier erfolgen das Lesen und Schreiben von Datenströmen sowie die Behandlung von I/O-Fehlern.
    \item EventLogger (Logging): Eine Hilfsklasse zur Protokollierung. Sie stellt statische Methoden bereit, um Systemereignisse und Fehler mit Zeitstempeln in getrennte Dateien (events.txt, errors.txt) zu speichern.
    \item DuplicateUserException: Eine eigene definierte, geprüfte Ausnahme (Checked Exception), die zur Steuerung des Programmflusses bei redundanten Registrierungsversuchen eingesetzt wird.
\end{itemize}

\lstinputlisting[language=Java, firstnumber=6, caption=DuplicateUserException Z.6-12]{./Quellcode/DuplicateUserException.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/DuplicateUserException.java Z.6-14
    \end{small}
\end{center} 

\subsection{Implementierungsdetails und Ablaufsteuerung}
\subsubsection{Der Registrierungsprozess}
Der Registrierungsvorgang (Main.handleRegister) beginnt mit einer lokalen Validierung der Eingabedaten. E-Mail-Adressen werden auf strukturelle Integrität (Präsenz eines '@'-Zeichens) und Passwörter auf eine Mindestlänge von 6 Zeichen geprüft. Validierungsfehler führen zu einem sofortigen Abbruch und zur entsprechenden Protokollierung.
Nach erfolgreicher Validierung delegiert die Steuerung an den UserStore. Die Methode addUser lädt zunächst den bestehenden Datenbestand (loadAllUsers), um Redundanzen auszuschließen. Sollte der Benutzer bereits existieren, wird eine DuplicateUserException geworfen, die von der aufrufenden Schicht (Main) abgefangen und in eine benutzerfreundliche Fehlermeldung umgewandelt wird. Technische Schreibfehler (z. B. IOException) werden an dieser Stelle lediglich protokolliert, um einen Programmabsturz zu verhindern.

\clearpage
\lstinputlisting[language=Java, firstnumber=86, caption=Main Z.86-92]{./Quellcode/Main1.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/Main.java Z.86-92
    \end{small}
\end{center} 

\subsubsection{Der Authentifizierungsprozess (Login)}
Beim Login (Main.handleLogin) wird mittels UserStore.findByEmail(email) der Datenbestand abgefragt. Eine Besonderheit ist hier der Rückgabetyp: Statt null zurückzugeben, wenn kein Nutzer gefunden wird, liefert die Methode ein Objekt vom Typ Optional<User> \footcite[Vgl.][]{Oracle_d}. In der Steuerungslogik wird mittels .isPresent() geprüft, ob ein Nutzer existiert. Ist dies der Fall, wird der Hash des eingegebenen Passworts berechnet und mit dem gespeicherten Hash des gefundenen Nutzers verglichen. Stimmen beide Hashes überein, gilt der Benutzer als authentifiziert.
\lstinputlisting[language=Java, firstnumber=105, caption=Main Z.105-114]{./Quellcode/Main2.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/Main.java Z.105-114
    \end{small}
\end{center} 
\clearpage
 \subsection{Robustheit der Persistenzschicht}
 Besonderes Augenmerk wurde auf die Fehlertoleranz beim Einlesen der Daten (UserStore.loadAllUsers) gelegt. Der Parser ist so implementiert, dass korrupte Einzeldatensätze (z. B. durch Formatierungsfehler) nicht zum Abbruch des gesamten Ladevorgangs führen. Stattdessen werden fehlerhafte Zeilen übersprungen und im Error-Log vermerkt. Eine fehlende Datenbankdatei (NoSuchFileException) wird vom System als leerer Initialzustand interpretiert, was die Benutzerfreundlichkeit beim ersten Programmstart sicherstellt.

\lstinputlisting[language=Java, firstnumber=69, caption=UserStore Z.69-80]{./Quellcode/UserStore1.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/UserStore.java Z.69-80
    \end{small}
\end{center} 
\clearpage
 \subsection{Technische Schlüssellösungen}
 Ressourcenmanagement: Zur Vermeidung von Speicherlecks wird konsequent das try-with-resources-Konstrukt eingesetzt, das das automatische Schließen von Streams (AutoCloseable) garantiert \footcite[Vlg.][]{Oracle_b}.
 
\lstinputlisting[language=Java, firstnumber=66, caption=UserStore Z.66]{./Quellcode/UserStore2.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/UserStore.java Z.66
    \end{small}
\end{center} 

Thread-Sicherheit: Zentrale Methoden in UserStore und EventLogger sind als synchronized deklariert, um bei potenziellen Dateioperationen Race Conditions zu vermeiden \footcite[Vgl.][]{Oracle_e}.

\lstinputlisting[language=Java, firstnumber=37, caption=UserStore Z.37]{./Quellcode/Eventlogger1.java}
\begin{center}
    \begin{small}
        Quelle: Abschnitt von Projektarbeit-Programmieren/src/Eventlogger.java Z.37
    \end{small}
\end{center} 